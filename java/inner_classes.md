- [Назад](/./java.md)

## Вложенные и внутренние классы

+ [Вложенные классы, nested classes](#Nested)
+ [Внутренние классы, inner classes](#Inner)
+ [Локальные классы, local classes](#Local)
+ [Анонимные классы, anonymous class](#Anonymous)


Вложенные классы - **nested classes**
Внутренние классы - **inner classes**

Вложенные классы могут быть static и non-static. non-static - и есть внутренние классы.

### <a name="Nested"></a> Вложенные классы, nested classes

Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, можно сделать внутренний класс статическим static. Такой класс называют вложенным nested. Применение статического внутреннего класса означает следующее :

- для создания объекта статического внутреннего класса не нужен объект внешнего класса;
- из объекта вложенного класса нельзя обращаться к нестатическим членам внешнего класса.

Вложенный класс имеет доступ к членам своего внешнего класса, в том числе и к закрытым членам. Однако, внешний класс не имеет доступа к членам вложенного класса. Вложенный класс при этом является членом внешнего класса.

Статический класс объявляется ключевым словом static. При этом класс должен обращаться к нестатическим членам своего внешнего класса при помощи объекта, т.е. он не может обращаться напрямую на нестатические члены своего внешнего класса. На практие подобные классы используются редко.


### <a name="Inner"></a> Внутренние классы, inner classes

Нестатические вложенные классы называют также внутренними классами inner class. Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них. Внутренние классы создаются внутри окружающего класса.

### <a name="Local"></a> Локальные классы, local classes

Локальные классы объявляются внутри методов основного класса и могут быть использованы только внутри этих методов. Они имеют доступ к членам внешнего класса, а также как к локальным переменным, так и к параметрам метода при одном условии - переменные и параметры используемые локальным классом должны быть задекларированы final. Локальные классы не могут содержать определение (но могут наследовать) статических полей, методов и классов (кроме констант).

 Пример :

   ```java
public class Student {
    private static final String NAME = "VASYA";
    private int age;

    private void  getNonStaticNested() {
        // Создаем экземпляр внутреннего класса
        NonStaticNested nonStaticNested = new NonStaticNested();
        nonStaticNested.method1(); // Имееем доступ к private методу
        nonStaticNested.ageInner = 5; // Имеем доступ к private полю
    }
    private void getStaticNestedMethod2() {
        // Создаем экземпляр статического вложенного класса
        StaticNested staticNested = new StaticNested();
        staticNested.ageStaticInner = 6; // Имеем доступ к private полю
        staticNested.method2(); // Имеем доступ к private методу
    }

    private void withInnerClass(final int intParameter) {

        // Локальный класс
        class Local {
            private int asd;

            private void method3() {
                age = 5; // Имеем доступ к private полям внешнего класса
                System.out.println(intParameter); // Имеем доступ к параметру метода, только когда он final
                asd = 56;
            }
        }

        // Создаем экземпляр локального класса
        Local local = new Local();
        System.out.println(local.asd); // Имеем доступ к private полю
        local.method3(); // Имеем доступк private методу
    }

    // Не статический вложенный класс - внутренний
    private class NonStaticNested {
        private int ageInner;
        private int age; // Маскирует поле внешнего класса

        private void method1() {
            age = 5; // Обращаемся к полю этого класса
            Student.this.age = 7; //  Имеем доступ к private полю
            getNonStaticNested(); // Имеем доступ к private методу
            System.out.println(NAME); // Имеем доступ к статическим private полям
        }
    }

    // Статический вложенный класс
    public static class StaticNested {
        private int ageStaticInner;

        private void method2() {
            // Доступа к полям и методам внешнего класса нет, т.к. нет экземпляра класса
//            Student.this.age = 7;
//            getNonStaticNested();

            System.out.println(NAME); // Имеем доступ к статическим private полям

            // Создаем экземпляр внешнего класса
            Student student = new Student();
            student.getNonStaticNested(); // Имеем доступ к private методам
            student.age = 34; // Имеем доступ к private полям
        }
    }
}
   ```

### <a name="Anonymous"></a> Анонимные классы, anonymous class

Анонимные классы декларируются внутри методов основного класса и могут быть использованы только внутри этих методов. В отличие от локальных классов, анонимные классы не имеют названия. Главное требование к анонимному классу - он должен наследовать существующий класс или реализовывать существующий интерфейс. Анонимные классы не могут содержать определение статических полей, методов и классов (кроме констант), но могут их наследовать.

Основное ограничение при использовании анонимных классов - это невозможность описания конструктора, так как класс не и меет имени. Аргументы, указанные в скобках, автоматически используются для вызова конструктора базового класса с теми же параметрами. Вот пример :

 ```java
class Clazz
{ 
    Clazz(int param) { } 
 
    public static void main(String[] args) { 
        new Clazz(1) { }; // правильное создание анонимного класса 
        new Clazz( ) { }; // неправильное создание анонимного класса 
    } 
} 
 ```
 
Так как анонимный класс является локальным классом, он имеет все те же ограничения, что и локальный класс.

Использование анонимных классов оправдано во многих случаях, в частности когда:

- тело класса является очень коротким;
- нужен только один экземпляр класса;
- класс используется в месте его создания или сразу после него;
- имя класса не важно и не облегчает понимание кода.

