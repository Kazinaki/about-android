- [Назад](/./java.md)

## Синхронизация

### Состояния потоков

Мы можем создать поток и запустить его, но как состояние потока меняется дальше зависит от реализации системного планировщика потоков (Threads scheduler) - в Java нет полного контроля над этим процессом.

![Состояния потоков](/./img/threads01.png)

Поток может быть в таких состояниях:

1. **New** - только что созданный поток, он еще не работает.
1. **Runnable** - когда вызываем `start()` объекта `Thread`, его состояние меняется на это и управление потоком передается планировщику потоков. Запустит ли он его мгновенно или поставит его в очередь в пуле потоков зависит уже от планировщика.
1. **Running** - поток запущен. Планировщик выбирает один поток из своего пула потоков и меняет его состояние на `Running`, после этого процессор начинает выполнение потока.
1. **Blocking** или **Waiting** - поток заблокирован или ожидает. После окончания ожидания, состояние потока меняется на `Runnable` и он возвращается в пул потоков планировщика.
1. **Dead** - поток завершил выполнение. Вернуться к нему уже нельзя.

Существует перечисление `Thread.State`, содержащее значения возможных состояний потока: `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, `TERMINATED`.

 Получить текущее значение состояния потока можно вызовом метода getState() класса Thread.
 
### Мониторы

Каждый объект в java имеет свой специальный объект для синхронизации потоков - мьютекс. Но доступ к нему сделан через другой спец. объект - монитор. Для взаимного исключения и синхронизации используются следующие операции:

- **monitorenter** - захват монитора. В один момент времени монитором может владеть только один поток. Если на момент попытки захвата, монитор уже был захвачет, то поток будет ждать пока монитор не освободится. В очереди могут быть несколько потоков.
- **monitorexit** - освобождение монитора
- **wait** - перемещение текущего потока в т.н. **wait set** монитора и ожидание того, как произодет `notify`. После того, как поток, владеющий монитором, сделал `wait`, монитором может завладеть другой поток.
- **notify(all)** - пробуждается один (или все) поток, который находится в **wait set**-е монитора. Чтобы получить управление поток должет успешно захватить монитор `monitorenter`.

Т.е. создаем какой-нибудь объект, он будет монитором и используем его в блоке `synchronized`.


### Блокировка на уровне объекта

Нужно использовать когда нужна синхронизация на уровне экземпляра. Происходит на уровне НЕ статического метода или НЕ статического блока кода.

Примеры:

```java
public class DemoClass {
    public synchronized void demoMethod() {}
}
```

```java
public class DemoClass {
    public void demoMethod() {
        synchronized (this) {
            // ...
        }
    }
}
```

```java
public class DemoClass {
    private final Object lock = new Object();
    public void demoMethod() {
        synchronized (lock) {
            // ...
        }
    }
}
```

### Блокировка на уровне класса

Когда нужно синхронизировать статические данные. Монитором выступает экземпляр класса `Class`.

Примеры:

```java
public class DemoClass {
    public synchronized static void demoMethod() {}
}
```

```java
public class DemoClass {
    public void demoMethod() {
        synchronized (DemoClass.class) {
            // ...
        }
    }
}
```

```java
public class DemoClass
{
    private final static Object lock = new Object();
    public void demoMethod(){
        synchronized (lock) {
            // ...
        }
    }
}
```

### Wait, notify, notifyAll

Эти методы реализованы как `final` в классе `Object`, поэтому они доступны все классам. Все они могут быть вызваны только из `synchronized` контекста.

`wait()` принуждает вызывающий поток отдать монитор и приостановить выполнение, пока другой поток не захватит этот монитор и не вызовет `notify()` или `notifyAll()`.

`notify()` возобновляет работу потока, который вызвал `wait()` на том же объекте.

`notifyAll()` возобновляет работу всех потоков, которые вызвали `wait()` на этом же мониторе. На самом деле, конечно, монитор захватывает только один поток. Какой - хз.
