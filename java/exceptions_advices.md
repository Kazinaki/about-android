- [Назад](/./java.md)

## Советы по работе с исключениями

### Выбрасывайте искючения, соотвествующие текущему уровню абстракции

Если в методе получаем исключение из нижнего уровня абстракции, то его следует перехватить и выбросить исключение текущего уровня. Иначе, это приведет к запутыванию и засорению интерфейса деталями реализации.

Вот пример из класса `AbstractSequentialList`, он обрабатывает исключение нижнего уровня `NoSuchElementException` и наверх выбрасывает `IndexOutOfBoundsException`.
   
   ```java
/**
* Возвращает элемент, находящийся в указанной позиции в этом списке.
* @throws IndexOutOfBoundsException, если индекс находится
* за пределами диапазона (index < 0 || index >= size()).
*/
public E get(int index) {
    ListIterator<E> i = listIterator(index);
    try {
        return i.next();
    } catch (NoSuchElementException e) {
        throw new IndexOutOfBoundsException("Index: " + index);
    }
}
   ```

### Используйте сцепление исключений

Если на верхнем уровне абстракции надо знать об исходном исключении, то можно использовать *сцепление исключений*. Для этого в конструктор нового исключение передать исходное исключение, тогда оно будет доступно методом `getCause()`.

   ```java
try {
    // Используем абстракцию нижнего уровня
    // для выполнения нашей задачи
    ...
} catch (LowerLevelException cause) {
    throw new HigherLevelException(cause);
}
   ```
    
Однако злоупотреблять этим не стоит, лучше исключить исключения )))

### Добивайтесь атомарности по отношению к исключениям

Это значит, надо делать так чтобы при выбрасывании исключения, объект, в ходе работы с которым оно было выброшено, должен находиться в полне определенном состоянии.

**failure atomic** - атомарность по отношению к сбоям - так называется свойство метода, когда метод, завершившийся сбоем оставляет объект в том же состоянии, в каком он был перед вызовом метода.

Для этого есть несколько способов:

1. Неизменяемые объекты. Тут все понятно.
1. Проверка правильности параметров перед выполнением операции. Сначала проверяем условия, выбрасываем исключение, если они не выполнены, только потом изменяем объект.
1. Написание специального кода восстановления (recovery code), который перехватывает сбой, и возвращает объект в исходное состояние.
1. Создание копии объекта, работа с ней, и только если не было исключений, присвоение объекту значения копии.

### Как можно перехватывать все исключения в программе

Для этого есть статический метод

`Thread.setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`

Пример кода:
```java
Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        logger.error("UnCaughtException", e);
    }
```
