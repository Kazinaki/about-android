- [Назад](/./java.md)

## Реализация HashMap

HashMap содержит массив элементов внутреннего класса `Node`. У него есть свойства `hash`, `key`, `value`, `next` (типа `Node`).
При вставке создается элемент `Node`, вычисляется хэш ключа, по нему вычисляется индекс в массиве и туда вставляется этот элемент. Если там уже есть элемент с другим ключем, то новый у него смотрится свойство `next`, если пустое, то новый элемент записывается туда, если там есть значение, то у него смотрится `next` и т.д. Т.е. если у класса, представляющего ключ, переопределен метод `hashCode()` и он возвращает повторяющиеся значения (или вообще одно и то же) для разных элементов, то они будут занимать одно место в во внутреннем массиве и сунуты в цепочку свойств `next`.

При поиске элемента так же вычисляется хэш ключа, по нему индекс, потом смотрится элемент по этому индексу, сравнивается его ключ по `equals`, если он не равен берется значение `next` этого элемента и сравнивается его ключ и т.д. по этому связанному списку.

Отсюда и правило: если переопределяем `equals()`, то надо соответственно переопределить `hashCode()`, иначе все быстродействие HashMap теряется.

В Java 8 после достижения определенного порога связанных элементов используются сбалансированные деревья, чтобы увеличить быстродействие. Хотя по идее, это говорит о том, что какой-то косяк с `equals` и `hashCode`.

### Важные моменты

1. Сложность операций get() и put() практически константна до тех пор, пока не будет проведенно повторное хэширование.
1. В случае коллизий, если индексы двух и более объектов node одинаковые, объекты node соединяются с помощью связанного списка, т.е. ссылка на второй объект node хранится в первом, на третий во втором и т.д.
1. Если данный ключ уже существует в HashMap, значение перезаписывается.
1. Хэш код null равен 0.
1. Когда объект получается по ключу происходят переходы по связанному списку до тех пор, пока объект не будет найден или ссылка на следующий объект не будет равна null.
