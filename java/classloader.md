- [Назад](/./java.md)

## Classloader

Загрузчик классов используется для поставки в JVM скомпилированного байт-кода классов, который как правило, хранится в файлах `.class`, хотя может быть получен и из сети, и сгенерирован самим приложением. После загрузки приложение может использовать полученный класс.

Класс `ClassLoader` абстрактный, загрузку выполняют его наследники.

В начале работы программы создается 3 загрузчика:

1. Базовый загрузчик (`bootstrap`)
1. Загрузчик расширений (`extension`)
1. Системный загрузчик (`system/application`)

### Базовый загрузчик. Bootstrap

Именно он загружает внутренние классы `JDK` и пакеты `java.* (rt.jar и i18n.jar)`. Важно заметить, что базовый загрузчик является «Изначальным или Корневым» и частью `JVM`, вследствие чего его нельзя создать внутри кода программы.

### Загрузчик расширений. Extention

Загружает различные пакеты расширений, которые располагаются в директории `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом `sun.misc.Launcher$ExtClassLoader. `

### Системный загрузчик. System

Загружает классы, пути к которым указаны в переменной окружения `CLASSPATH` или пути, которые указаны в командном рядке после ключей  `–classpath` или `–cp`. Системный загрузчик реализован классом `sun.misc.Launcher$AppClassLoader`.

Именно он загружает программу, когда мы запускаем ее вызовом

> java Имя_главного_класса



## Три принципа загрузки классов

### Делегирование

Запрос на загрузку класса передается родительскому загрузчику, и попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик не смог найти и загрузить класс. Такой подход позволяет загружать классы тем загрузчиком, который максимально близко находится к базовому. Так достигается максимальная область видимости классов. Каждый загрузчик ведет учет классов, которые были загружены именно им, помещая их в свой кэш. Множество этих классов и называется областью видимости.

### Видимость

Загрузчик видит только «свои» классы и классы «родителя» и понятия не имеет о классах, которые были загружены его «потомком».

### Уникальность

Класс может быть загружен только однажды. Механизм делегирования позволяет убедиться, что загрузчик, инициирующий загрузку класса, не перегрузит загруженный ранее в JVM класс.

Таким образом, при написании своего загрузчика разработчик должен руководствоваться этими тремя принципами.



## Схема загрузки классов

Каждый загрузчик (кроме `Bootstrap`) имеет родительский загрузчик, которого он и запрашивает загрузить класс в начале. 

Иерархия загрузчиков:

1. Bootstrap
1. Extensions
1. System
1. Пользовательские загрузчики

Каждый загрузчик имееет кэш классов, где хранятся загруженные ранее им классы. Так же каждый класс имеет информацию о загрузчике, которым он был загружен. И когда класс обращается к какому-то другому классу, который раньше не был загружен, то он обращается к своему загрузчику. 
1. Тот смотрит свой кэш, если класс там есть, то возвращает объект `Class`.
1. Если класса в кэше нет, он делегирует загрузку класса своему родителю.
1. И т.д. до `Bootstrap`-загрузчика. Он, если класс не найден в кэше, пытается загрузить его по своему местоположению. 
1. Если класс не найден, он говорит об этом наследнику, который у нему обратился.
1. Наследник уже сам пытается загрузить класс по своему местоположению.
1. И т.д. если класс не был загружен родительскими загрузчиками, поток возвращается к первоначальному загрузчику, который делает попытку загрузить его сам.
1. Если и тут класс не найден, то бросается исключение `java.lang.ClassNotFoundException`.



