- [Назад](/./java.md)

## Исключения

![Иерархия исключений](/./img/exceptions.png)

Все исключения наследуются от класса `Throwable`. Прямые наследники: `Error` и `Exceptions`.  Делятся на проверяемые (unchecked) и непроверяемые (unchecked).

`Error` - класс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются непроверяемые (unchecked). 

`RuntimeExceptions` - возникающие во время выполнения (на самом деле это вводит в заблуждение, т.к. все ошибки возникают во время выполнения), тоже непроверяемые. Практически всегда возникают по вине программиста. Основные исключения:
- Неверное приведение типов.
- Выход за пределы массива.
- Попытка обратиться к объекту `null`.
- Попытка открыть несуществующий файл.

Виды исключений:
1. Checked - должны обрабатываться блоком `try/catch` или описываться в сигнатуре метода. Для этих типов компилятор проверяет наличие обработки этих исключений.
1. Unchecked - можно не обрабатывать.

Если в коде есть участок который может бросить `checked` исключение то надо либо заключить его в конструкцию `try/catch` либо объявить в сигнатуре метода `throws SomeException`, но в данном случае обработка исключения делегируется на уровень выше. В любом случае его нужно будет перехватить. В противном случае программа просто не скомпилируется.

Из `Error` стоит знать наиболее общеизвестные, это:

`OutOfMemoryError` - кончилась память.

`AssertionError` - ошибка в условии оператора assert, начиная с Java 1.4.

`ThreadDeath` - кидается в останавливаемом потоке, при вызове у него метода `stop()`.

`NoSuchMethodError` - обычно отсутствует метод `main`.

`NoClassDefFoundError` - отсутствует код загружаемого класса.

### Обработка исключений

Основная идея - метод генерирует исключение, если возникла ситуация с которой он не может справиться.

Если указываем несколько блоков `catch`, то порядок из должен быть - от частного исключения к общему.

### Использование ресурсов

Если надо задать какой-то ресурс для работы в блоке `try`, то можно задать его вот так:

  ```java
try (Resource res = ...) {
    используем ресурс
}
  ```
  
После выполнения блока `try` будет вызван метод `res.close()`. Для этого ресурс должен реализовать интерфейс `AutoClosable`.

### Анализ трассировки стека

Для получения текстового описания трассировки стека можно вызвать метод `printStackTrace` из класса `Throwable`:
  ```java
Throwable t = new Throwable();
t.printStackTrace();
  ```
  
Более удобный метод `getStackTrace()` возвращает массив объектов `StackTraceElement`, который можно проанализоровать:

  ```java
Throwable t = new Throwable();
StackTraceElement[] frames = t.getStackTrace();
for (StackTraceElement frame : frames) {
    анализ фрейма
}
  ```
  
Получаемый таким образом элемент `StackTraceElement` имеет методы для получения имени файла, номера исполняемой строки кода, а также имя класса и метода.
Есть также метод `Thread.getAllStackTraces()` - он позволяет получить трассировку стека во всех потоках.

```java
Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
for (Thread t : map.keySet()) {
    StackTraceElement[] frames = map.get(t);
}
```

[Советы по работе с исключениями](/java/exceptions_advices.md)
