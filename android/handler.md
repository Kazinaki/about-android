- [Назад](/./android.md)

## Handler

### Основные определения

1. android.os.**Looper** - диспетчер сообщений, связанный только с одним потоком-потребителем.
1. android.os.**Handler** - обработчик сообщений для потока-потербителя и соответствующий интерфейс для потока-производителя, позволяющий помещать сообщения в очередь. Объект типа **Looper** может иметь несколько связанных с ним обработчиков, но все они помещают сообщения в одну и ту же очередь.
1 android.os.**MessageQueue** - неограниченный по размеру связанный список сообщений, который должен обрабатываться в потоке-потребителе. Каждый объект типа **Looper* (и **Thread**) имеет не более одной очереди.
1. android.os.**Message** - сообщение, которое должен обработать поток-потребитель.

### Механизм передачи-приема сообщений

**Handler** позволяет отправлять и обрабатывать сообщения (**Message**) и объекты **Runnable** в связанную с потоком очередь сообщений (**MessageQueue**). Каждый объект **Handler** связан с одним потоком (у потока же может быть несколько **Handler**-ов) и очередью сообщений этого потока. Когда создается **Handler** он связывается с объектом **Looper**. Он передает сообщения и объекты **Runnable** в очередь сообщений этого **Looper**-а и обрабатывает их в потоке **Looper**-а. Сам **Looper** работает в потоке-потребителе, извлекает сообщения из очереди, для передачи их соответствующему **Handler**-у.

![](/./img/handler01.png)

Каждое сообщение содержит ссылку на следующее в очереди.

### Код

Есть два главных использоватья **Handler**-а:
1. запланировать сообщения и **Runnable** на выполнение в будущем.
1. ставить в очередь действия на выполнение в другом потоке.

Есть два вида методов для планирования действий:
1. передавая объект **Runnable**
```java
post(Runnable)
postAtTime(java.lang.Runnable, long)
postDelayed(Runnable, Object, long)
```
2. передавая **Message**
```java
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message, long)
sendMessageDelayed(Message, long)
```

### Класс MessageQueue

Очередь сообщений представляет собой неограниченный однонаправленный список. Сообщения сортируются по отметкам времени (timestamp). Если эта отметка меньше текущего времени, оно отправляется потоку-получателю на обработку. Потоки-производители могут вставлять сообщения в любое время и на любую позицию.

### Интерфейс MessageQueue.IdleHandler

Предназначен для обработки ситуаций, когда в очереди нет сообщений готовых для отправки (их время не пришло). По умолчанию поток-потребитель просто ждет новых сообщений, но вместо этого он может использоваться для других задач. Этот интерфейс определяет слушателя, который связывается с очередью **MessageQueue**

```kotlin
MessageQueue mq = Looper.myQueue()
val idleHandler = MessageQueue.IdleHandler()
mq.addIdleHandler(idleHandler) // регистрация наблюдателя
mq.removeIdlehandler(idleHandler) // отписка наблюдателя
```

Интерйес имеет один метод
```kotlin
interface IdleHandler {
    fun queueIdle() : Boolean
}
```
В реализации этого метода надо возвращать **Boolean**
- **true** - если слушатель после обработки остается активным и принимаем следующие вызовы.
- **false** - если слушатель после обработки считается не активным. Это равно отмене подписки.
