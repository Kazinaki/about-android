- [Назад](/./kotlin.md)

## Unit

Unit эквивалентен void в Java.
В стандартной библиотеке Kotlin Unit определён как объект, наследуемый от Any и содержащий единственный метод, переопределяющий toString():

```kotlin
public object Unit {
	override fun toString() = "kotlin.Unit"
}
```
Т.к. он object, то он синглтон.

## Nothing

Nothing — класс, который является наследником любого класса в Kotlin, даже класса с модификатором final. При этом Nothing нельзя создать — у него приватный конструктор.
Зачем же его использовать? Так как невозможно передать или вернуть тип Nothing, он описывает результат «функции, которая никогда ничего не вернёт». Примером может быть функция, которая выбрасывает exception или в которой запущен бесконечный цикл: в любом из этих случаев она никогда не вернёт значения. В приложениях — независимо от того, какой тип данных возвращает функция, — она может никогда не вернуть данные, потому что произошла ошибка или вычисления затянулись на неопределённый срок. В этом случае имеет смысл использовать Nothing.

Например: функция TODO(), которая часто служит заглушкой в автоматически генерируемых методах. 
```kotlin
public inline fun TODO(): Nothing = throw NotImplementedError()
```
Например функцию

```kotlin
fun getData(): List<Data> {
   TODO("not implemented")
}
```
Можно написать так:
```kotlin
fun getData(): List<Data> = TODO("not implemented")
```
И хотя возвращаемое значение тут List<Data>, мы возвращаем Nothing. Код скомпилируется, потому что Nothing наследуется от всех классов.
Интересно, что в Java нельзя написать что-то подобное: код просто не скомпилируется, потому что Void не наследуется от List<Data>

## Any

Класс Any находится на вершине иерархии — все классы в Kotlin являются наследниками Any. Any — это аналог Object в Java, но с меньшим количеством методов: 

```kotlin
public open class Any {
    public open operator fun equals(other: Any?): Boolean
    public open fun hashCode(): Int
    public open fun toString(): String
}
```

В java.lang.Object одиннадцать методов, и пять из них касаются многопоточности. Несмотря на меньшее количество методов, при компиляции в Java-код у любого класса появятся недостающие — тут можно быть спокойными.
